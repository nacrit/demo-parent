备忘录（Memento）模式（标记（Token）模式）：
    在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后 就可将该对象恢复到原先保存的状态。

    来看下“月光宝盒”备忘录模式的组成部分：
        1) 备忘录（Memento）角色：备忘录角色存储“备忘发起角色”的内部状态。“备忘发起 角色”根据需要决定备忘录角色存储“备忘发起角色”的哪些内部状态。
            为了防止“备忘发起角色”以外的其他对象访问备忘录。备忘录实际上有两个接口，“备忘录管理者 角色”只能看到备忘录提供的窄接口——
            对于备忘录角色中存放的属性是不可见的。“备 忘发起角色”则能够看到一个宽接口——能够得到自己放入备忘录角色中属性。
        2) 备忘发起（Originator）角色：“备忘发起角色”创建一个备忘录，用以记录当前时刻它的内部状态。在需要时使用备忘录恢复内部状态。
        3) 备忘录管理者（Caretaker）角色：负责保存好备忘录。不能对备忘录的内容进行操作或检查。


    举例:对三种在 Java 中可保存封装的方法进行探讨。
        第一种就是采用两个不同的接口类来限制访问权限。这两个接口类中，一个提供比较完备的操作状态的方法，我们称它为宽接口；
            而另一个则可以只是一个标示，我们称它为窄接口。备忘录角色要实现这两个接口类。
            这样对于“备忘发起角色”采用宽接口进行访问，而对于其他的角色或者对象则采用窄接口进行访问。
            这种实现比较简单，但是需要人为的进行规范约束——而这往往是没有力度的。
        第二种方法便很好的解决了第一种的缺陷：采用内部类来控制访问权限。将备忘录角色作为“备忘发起角色”的一个私有内部类。
            好处我不详细解释了，看看代码吧就明白了。下面的代码是一个完整的备忘录模式的教学程序。它便采用了第二种方法来实现备忘录模式。
            还有一点值得指出的是，在下面的代码中，对于客户程序来说“备忘录管理者角色”是不可见的，这样简化了客户程序使用备忘录模式的难度。
            下面采用“备忘发起角色”来调用访问“备忘录管理者角色”，也可以参考门面模式在客户程序与备忘录角色之间添加一个门面角色。

    适用情况
        从上面的讨论可以看出，使用了备忘录模式来实现保存对象的历史状态可以有效地保持封装边界。
        使用备忘录可以避免暴露一些只应由“备忘发起角色”管理却又必须存储在“备忘发起角色”之外的信息。
        把“备忘发起角色”内部信息对其他对象屏蔽起来, 从而保持了封装边界。
        但是如果备份的“备忘发起角色”存在大量的信息或者创建、恢复操作非常频繁，则可能造成很大的开销。
        GOF 在《设计模式》中总结了使用备忘录模式的前提：
        1) 必须保存一个对象在某一个时刻的(部分)状态, 这样以后需要时它才能恢复到先前的状态。
        2) 如果一个用接口来让其它对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。

    总结
        介绍了怎样来使用备忘录模式实现存储对象历史状态的功能，并对基于 Java 的实现进行了讨论。
