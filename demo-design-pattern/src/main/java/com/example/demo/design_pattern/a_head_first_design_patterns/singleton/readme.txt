单例设计模式（单态模式或者单件模式）：
    保证一个类仅有 一个实例，并提供一个访问它的全局访问点。
    单例模式可分为有状态的和无状态的。
        有状态的单例对象一般也是可变的单例对象，多 个单态对象在一起就可以作为一个状态仓库一样向外提供服务。
        没有状态的单例对象也就是 不变单例对象，仅用做提供工具函数
    懒汉式和饿汉式：
        懒汉式中，对静态工厂方法进行了同步处理，原因很明显——为了防止多线程环 境中产生多个实例；而在饿汉式中则不存在这种情况。
        在懒汉式中将类对自己的实例化延迟到第一次被引用的时候。而在第一种方式中则 是在类被加载的时候实例化，这样多次加载会照成多次实例化。
        但是懒汉式由于使用了同步处理，在反应速度上要比第一种慢一些。
    采用带有注册表的方式：
        由于在 java 中子类的构造函数的范围不能比父类的小，所以可能存在不守规则的客户
        程序使用其构造函数来产生实例，造成单例模式失效。

单例模式邪恶论
    多个虚拟机：当系统中的单例类被拷贝运行在多个虚拟机下的时候，在每一个虚拟机下都可以创建一个实例对象。
        在使用了 EJB、JINI、RMI 技术的分布式系统中，由于中间件屏蔽掉了分布式系统在物理上的差异，
        所以对你来说，想知道具体哪个虚拟机下运行着哪个单例对象是很困难的。
        因此，在使用以上分布技术的系统中，应该避免使用存在状态的单例模式，因为一个有状态的单例类，在不同虚拟机上，
        各个单例对象保存的状态很可能是不一样的，问题也就随之产生。
        而且在 EJB 中不要使用单例模式来控制访问资源，因为这是由 EJB 容器来负责的。
        在其它的分布式系统中，当每一个虚拟机中的资源是不同的时候，可以考虑使用单例模式来进行管理。
    多个类加载器:有状态的单例模式也会给系统带来隐患。因此除非系统由协调机制，在一般情况下不要使用存在状态的单例模式。
    错误的同步处理：在使用上面介绍的懒汉式单例模式时，同步处理的恰当与否也是至关重要的。不然可能会达不到得到单个对象的效果，还可能引发死锁等错误。
        因此在使用懒汉式单例模式时一定要对同步有所了解。不过使用饿汉式单例模式就可以避免这个问题。
    子类破坏了对象控制:在上一节介绍最后一种扩展性较好的单例模式实现方式的时候，就提到，由于类构造函数变得不再私有，就有可能失去对对象的控制。这种情况只能通过良好的文档来规范。
    串行化（可序列化）：为了使一个单例类变成可串行化的，仅仅在声明中添加“implements Serializable”是不够的。
        因为一个串行化的对象在每次返串行化的时候，都会创建一个新的对象，而不仅仅是一个对原有对象的引用。
        为了防止这种情况，可以在单例类中加入 readResolve 方法。关于这个方法的具体情况请参考《Effective Java》一书第 57 条建议。

57. 最小化局部变量的作用域
这条目在性质上类似于条目 15，即“最小化类和成员的可访问性”。通过最小化局部变量的作用域，可以提高代码的可读性和可维护性，并降低出错的可能性。
较早的编程语言（如 C）要求必须在代码块的头部声明局部变量，并且一些程序员继续习惯这样做。
这是一个值得改进的习惯。 作为提醒，Java 允许你在任何合法的语句的地方声明变量（as does C, since C99）。
用于最小化局部变量作用域的最强大的技术是再首次使用的地方声明它。
如果变量在使用之前被声明，那就变得更加混乱—— 这也会对试图理解程序的读者来讲，又增加了一件分散他们注意力的事情。 到使用该变量时，读者可能不记得变量的类型或初始值。
过早地声明局部变量可能导致其作用域不仅过早开始而且结束太晚。 局部变量的作用域从声明它的位置延伸到封闭块的末尾。
如果变量在使用它的封闭块之外声明，则在程序退出该封闭块后它仍然可见。如果在其预定用途区域之前或之后意外使用变量，则后果可能是灾难性的。
几乎每个局部变量声明都应该包含一个初始化器。如果还没有足够的信息来合理地初始化一个变量，那么应该推迟声明，直到认为可以这样做。
这个规则的一个例外是 try-catch 语句。如果一个变量被初始化为一个表达式，该表达式的计算结果可以抛出一个已检查的异常，那么该变量必须在 try 块中初始化 (除非所包含的方法可以传播异常)。
如果该值必须在 try 块之外使用，那么它必须在 try 块之前声明，此时它还不能被“合理地初始化”。例如，参照条目65 中的示例。
循环提供了一个特殊的机会来最小化变量的作用域。传统形式的 for 循环和 for-each 形式都允许声明循环变量，将其作用域限制在需要它们的确切区域。 （该区域由循环体和 for 关键字与正文之间的括号中的代码组成）。
因此，如果循环终止后不需要循环变量的内容，那么优先选择 for 循环而不是 while 循环。
例如，下面是遍历集合的首选方式（条目 58）：
// Preferred idiom for iterating over a collection or array
for (Element e : c) {
    ... // Do Something with e
}
如果需要访问迭代器，也许是为了调用它的 remove 方法，首选的习惯用法，使用传统的 for 循环代替 for-each
循环：
// Idiom for iterating when you need the iterator
for (Iterator<Element> i = c.iterator(); i.hasNext(); ) {
Element e = i.next();
    ... // Do something with e and i
}
要了解为什么这些 for 循环优于 while 循环，请考虑以下代码片段，其中包含两个 while 循环和一个 bug：
Iterator<Element> i = c.iterator();
while (i.hasNext()) {
    doSomething(i.next());
}
...
Iterator<Element> i2 = c2.iterator();
while (i.hasNext()) { // BUG!
    doSomethingElse(i2.next());
}
第二个循环包含一个复制粘贴错误：它初始化一个新的循环变量 i2，但是使用旧的变量 i，不幸的是，它仍在范围内。
生成的代码编译时没有错误，并且在不抛出异常的情况下运行，但它做错了。 第二个循环不是在 c2 上迭代，而是立即终止，给出了 c2 为空的错误印象。
由于程序无声地出错，因此错误可能会长时间无法被检测到。
如果将类似的复制粘贴错误与 for 循环 (for-each 循环或传统循环) 结合使用，则生成的代码甚至无法编译。
第一个循环中的元素 (或迭代器) 变量不在第二个循环中的作用域中。下面是它与传统 for 循环的示例:
for (Iterator<Element> i = c.iterator(); i.hasNext(); ) {
Element e = i.next();
    ... // Do something with e and i
}
...
// Compile-time error - cannot find symbol i
for (Iterator<Element> i2 = c2.iterator(); i.hasNext(); ) {
Element e2 = i2.next();
    ... // Do something with e2 and i2
}
此外，如果使用 for 循环，那么发送这种复制粘贴错误的可能性要小得多，因为没有必要在两个循环中使用不同的变量名。
循环是完全独立的，因此重用元素（或迭代器）变量名称没有坏处。 事实上，这样做通常很流行。
for 循环比 while 循环还有一个优点：它更短，增强了可读性。
下面是另一种循环习惯用法，它最小化了局部变量的作用域:
for (int i = 0, n = expensiveComputation(); i < n; i++) {
    ... // Do something with i;
}
关于这个做法需要注意的重要一点是，它有两个循环变量，i 和 n，它们都具有完全相同的作用域。第二个变量 n
用于存储第一个变量的限定值，从而避免了每次迭代中冗余计算的代价。作为一个规则，如果循环测试涉及一个方法
调用，并且保证在每次迭代中返回相同的结果，那么应该使用这种用法。
最小化局部变量作用域的最终技术是保持方法小而集中。 如果在同一方法中组合两个行为（activities），则与一
个行为相关的局部变量可能会位于执行另一个行为的代码范围内。 为了防止这种情况发生，只需将方法分为两个：
每个行为对应一个方法。


优点：
1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。
2、避免对资源的多重占用（比如写文件操作）。
缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。



