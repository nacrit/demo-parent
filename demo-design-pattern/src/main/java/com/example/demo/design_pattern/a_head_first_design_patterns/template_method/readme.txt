u.模板方法（Template Method）模式：
    定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。

    个简单模式的结构吧：
        1) 抽象类（Abstract Class）：定义了一到多个的抽象方法，以供具体的子类来实现它们；
            而且还要实现一个模板方法，来定义一个算法的骨架。该模板方法不仅调用前面的抽象方法，也可以调用其他的操作，只要能完成自身的使命。
        2) 具体类（Concrete Class）：实现父类中的抽象方法以完成算法中与特定子类相关的步骤。

    （Abstract Class）    ------- ....
            |
    （Concrete Class)


    举例
        还是在我刚刚分析完源码的 JUnit 中找个例子吧。JUnit 中的 TestCase 以及它的子类就是一个模板方法模式的例子。
        在 TestCase 这个抽象类中将整个测试的流程设置好了，比如先执行 Setup 方法初始化测试前提，在运行测试方法，然后再 TearDown 来取消测试设置。
        但是你将在 Setup、TearDown 里面作些什么呢？鬼才知道呢！！因此，而这些步骤的具体实现都延迟到子类中去，也就是你实现的测试类中。
        来看下相关的源代码吧。
        这是 TestCase 中，执行测试的模板方法。你可以看到，里面正像前面定义中所说的那样，它制定了“算法”的框架——先执行 setUp 方法来做下初始化，然后执行测试方法，最后执行 tearDown 释放你得到的资源。
        public void runBare() throws Throwable {
            setUp();
            try {
                runTest();
            } finally {
                tearDown();
            }
        }
        这就是上面使用的两个方法。与定义中不同的是，这两个方法并没有被实现为抽象方法，而是两个空的无为方法（被称为钩子方法）。
        这是因为在测试中，我们并不是必须要让测试程序使用这两个方法来初始化和释放资源的。如果是抽象方法，则子类们必须给它一个实现，不管用到用不到。
        这显然是不合理的。使用钩子方法，则你在需要的时候，可以在子类中重写这些方法。
        protected void setUp() throws Exception {}
        protected void tearDown() throws Exception {}

    适用情况
        根据上面对定义的分析，以及例子的说明，可以看出模板方法适用于以下情况：
        1) 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。
        2) 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。其实这可以说是一种好的编码习惯了。
        3) 控制子类扩展。模板方法只在特定点调用操作，这样就只允许在这些点进行扩展。比如上面 runBare（）方法就只在 runTest 前面适用 setUp 方法。
            如果你不愿子类来修改你的模板方法定义的框架，你可以采用两种方式来做：一是在 API 中不体现出你的模板方法；或者将你的模板方法置为 final 就可以了。
            可以看出，使用模板方法模式可以将代码的公共行为提取出来，达到复用的目的。而且，在模板方法模式中，是由父类的模板方法来控制子类中的具体实现。
            这样你在实现子类的时候，根本不需要对业务流程有太多的了解。